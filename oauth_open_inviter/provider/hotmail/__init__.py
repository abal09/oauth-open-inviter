import urllib, urllib2
import xml.dom.minidom

from oauth_open_inviter.oauth_access.access import BaseAccess, OAuth2Access
from oauth_open_inviter.provider.base import BaseProvider
from oauth_open_inviter.lib.WindowsLiveLogin import WindowsLiveLogin

MAX_LIMIT = 25
START_INDEX = 1
MAX_RESULTS = 50

class HotmailOauthProvider(OAuth2Access, BaseProvider):
    """
    Class for getting contacts from gmail account
    (using OAuth2)
    """

    access_token_url = 'https://login.live.com/oauth20_token.srf'
    authorize_url = 'https://login.live.com/oauth20_authorize.srf'

    scope_urls = ['wl.basic']

    def search(self, base_url, extra_params=None,
               url=None, start_index=START_INDEX, max_results=MAX_RESULTS, **kwargs):
        feed_url = url or base_url
        url_params = {'offset': start_index, 'limit': max_results}
        if url:
            url_params = None
        else:
            if extra_params:
                url_params.update(extra_params)
        return self.make_api_call(url=feed_url, method="GET", params=url_params, **kwargs)

    def get_contacts(self, username='me', url=None, start_index=START_INDEX, max_results=MAX_RESULTS):
        base_url = 'https://apis.live.net/v5.0/%s/contacts' % username
        feed = self.search(base_url, url=url, start_index=start_index, max_results=max_results,
            kind='json', headers={'accept-encoding': 'gzip'})
        return feed

    def get_all_contacts(self, username='me'):
        next_link = None
        try:
            while True:
                feed = self.get_contacts(username=username, url=next_link)
                if feed:
                    accounts = feed.entries
                    next_link = feed.next_link
                    for accounts in accounts:
                        yield accounts
                if not next_link:
                    break
        except Exception, ex:
            pass


class HotmailProvider(BaseAccess, BaseProvider):

    def __init__(self, consumer_key, consumer_secret, policy_url, *args, **kwargs):
        """
        Initial function,
        Keyword arguments:
            - **consumer_key** -- Client ID key. Generated by Microsoft while new app registration
            - **consumer_secret** -- Client secret key. Generated by Microsoft while new app registration
            - **policy_url** -- Some url with Policy information
            additional for step 2:
            - **post_params** -- a dict with post data given from MS server after user authentification
        """
        self.consumer_key = consumer_key
        self.consumer_secret = consumer_secret
        self.policy_url = policy_url
        super(HotmailProvider, self).__init__(consumer_key, consumer_secret, *args, **kwargs)

    def get_tokens(self):
        return None

    def get_auth_url(self):
        wll = WindowsLiveLogin(appid=self.consumer_key, secret=self.consumer_secret,
            policyurl=self.policy_url, returnurl=self.callback_url)
        return wll.getConsentUrl("Contacts.View")

    def receive_access_tokens(self, http=None):
        return None

    def get_contacts(self):
        """
        Implements a generator for iterating in contacts
        """
        wll = WindowsLiveLogin(appid=self.consumer_key, secret=self.consumer_secret, policyurl=self.policy_url)

        consent_token = wll.processConsent(self.post_params)

        if not consent_token or not consent_token.isValid():
            raise Exception('Cannot give a contact list.')

        lid = consent_token.getLocationID()
        lid16 = int(lid, 16)
        to_signed_64 = lambda x: x < 2**63 and x or x - 2**64
        lid_s64 = to_signed_64(lid16)
        url = 'https://livecontacts.services.live.com/users/@C@%s/rest/invitationsbyemail' % lid_s64
        req = urllib2.Request(url)
        req.add_header(
            'Authorization', 'DelegatedToken dt="%s"' % urllib.unquote(consent_token.getDelegationToken())
        )
        response = urllib2.build_opener().open(req)
        return self.parse_contacts(response.read())

    def get_all_contacts(self, username='default'):
        return self.get_contacts()

    def parse_contacts(self, xml_string):
        dom = xml.dom.minidom.parseString(xml_string)
        xml_contacts = dom.getElementsByTagName("Contact")
        contacts = []

        if xml_contacts:
            for contact in xml_contacts:
                email = contact.getElementsByTagName("PreferredEmail")
                if not email:
                    continue

                name = []
                try:
                    name.append(contact.getElementsByTagName("FirstName")[0].childNodes[0].data)
                except Exception:
                    pass

                try:
                    name.append(contact.getElementsByTagName("LastName")[0].childNodes[0].data)
                except Exception:
                    pass

                contacts.append({
                    'name': ' '.join(name),
                    'emails': [email[0].childNodes[0].data, ]
                })
        return contacts